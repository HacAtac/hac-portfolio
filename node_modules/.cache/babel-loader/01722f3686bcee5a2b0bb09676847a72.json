{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.uniteEntries = exports.uniteRules = undefined;\n\nvar _unionWith2 = require('lodash/unionWith');\n\nvar _unionWith3 = _interopRequireDefault(_unionWith2);\n\nvar _differenceWith2 = require('lodash/differenceWith');\n\nvar _differenceWith3 = _interopRequireDefault(_differenceWith2);\n\nvar _mergeWith2 = require('lodash/mergeWith');\n\nvar _mergeWith3 = _interopRequireDefault(_mergeWith2);\n\nvar _isEqual2 = require('lodash/isEqual');\n\nvar _isEqual3 = _interopRequireDefault(_isEqual2);\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nvar isArray = Array.isArray;\n\nfunction uniteRules(rules, key, newRule, rule) {\n  if (String(rule.test) !== String(newRule.test) || (newRule.enforce || rule.enforce) && rule.enforce !== newRule.enforce || newRule.include && !isSameValue(rule.include, newRule.include) || newRule.exclude && !isSameValue(rule.exclude, newRule.exclude)) {\n    return false;\n  } else if (!rule.test && !rule.include && !rule.exclude && (rule.loader && rule.loader.split('?')[0]) !== (newRule.loader && newRule.loader.split('?')[0])) {\n    // Don't merge the rule if there isn't any identifying fields and the loaders don't match\n    return false;\n  } else if ((rule.include || rule.exclude) && !newRule.include && !newRule.exclude) {\n    // Don't merge child without include/exclude to parent that has either\n    return false;\n  } // apply the same logic for oneOf\n\n\n  if (rule.oneOf && newRule.oneOf) {\n    rule.oneOf = (0, _unionWith3.default)(rule.oneOf, newRule.oneOf, uniteRules.bind(null, {}, 'oneOf'));\n    return true;\n  } // newRule.loader should always override use, loaders and oneOf\n\n\n  if (newRule.loader) {\n    var optionsKey = newRule.options ? 'options' : newRule.query && 'query';\n    delete rule.use;\n    delete rule.loaders;\n    delete rule.oneOf;\n    rule.loader = newRule.loader;\n\n    if (optionsKey) {\n      rule[optionsKey] = newRule[optionsKey];\n    }\n  } else if (newRule.oneOf) {\n    delete rule.use;\n    delete rule.loaders;\n    delete rule.loader;\n    rule.oneOf = newRule.oneOf;\n  } else if ((rule.use || rule.loaders || rule.loader) && (newRule.use || newRule.loaders)) {\n    var expandEntry = function expandEntry(loader) {\n      return typeof loader === 'string' ? {\n        loader: loader\n      } : loader;\n    }; // this is only here to avoid breaking existing tests\n\n\n    var unwrapEntry = function unwrapEntry(entry) {\n      return !entry.options && !entry.query ? entry.loader : entry;\n    };\n\n    var entries = void 0;\n\n    if (rule.loader) {\n      var _optionsKey = rule.options ? 'options' : rule.query && 'query';\n\n      entries = [{\n        loader: rule.loader\n      }];\n\n      if (_optionsKey) {\n        entries[0][_optionsKey] = rule[_optionsKey];\n      }\n\n      delete rule.loader;\n\n      if (_optionsKey) {\n        delete rule[_optionsKey];\n      }\n    } else {\n      entries = [].concat(rule.use || rule.loaders).map(expandEntry);\n    }\n\n    var newEntries = [].concat(newRule.use || newRule.loaders).map(expandEntry);\n    var loadersKey = rule.use || newRule.use ? 'use' : 'loaders';\n    var resolvedKey = key + '.' + loadersKey;\n\n    switch (rules[resolvedKey]) {\n      case 'prepend':\n        rule[loadersKey] = [].concat(_toConsumableArray((0, _differenceWith3.default)(newEntries, entries, uniteEntries)), _toConsumableArray(entries)).map(unwrapEntry);\n        break;\n\n      case 'replace':\n        rule[loadersKey] = newRule.use || newRule.loaders;\n        break;\n\n      default:\n        rule[loadersKey] = combineEntries(newEntries, entries).map(unwrapEntry);\n    }\n  }\n\n  if (newRule.include) {\n    rule.include = newRule.include;\n  }\n\n  if (newRule.exclude) {\n    rule.exclude = newRule.exclude;\n  }\n\n  return true;\n}\n/**\n * Check equality of two values using lodash's isEqual\n * Arrays need to be sorted for equality checking\n * but clone them first so as not to disrupt the sort order in tests\n */\n\n\nfunction isSameValue(a, b) {\n  var _map = [a, b].map(function (value) {\n    return isArray(value) ? [].concat(_toConsumableArray(value)).sort() : value;\n  }),\n      _map2 = _slicedToArray(_map, 2),\n      propA = _map2[0],\n      propB = _map2[1];\n\n  return (0, _isEqual3.default)(propA, propB);\n}\n\nfunction areEqualEntries(newEntry, entry) {\n  var loaderNameRe = /^([^?]+)/ig;\n\n  var _entry$loader$match = entry.loader.match(loaderNameRe),\n      _entry$loader$match2 = _slicedToArray(_entry$loader$match, 1),\n      loaderName = _entry$loader$match2[0];\n\n  var _newEntry$loader$matc = newEntry.loader.match(loaderNameRe),\n      _newEntry$loader$matc2 = _slicedToArray(_newEntry$loader$matc, 1),\n      newLoaderName = _newEntry$loader$matc2[0];\n\n  return loaderName === newLoaderName;\n}\n\nfunction uniteEntries(newEntry, entry) {\n  if (areEqualEntries(newEntry, entry)) {\n    // Replace query values with newer ones\n    (0, _mergeWith3.default)(entry, newEntry);\n    return true;\n  }\n\n  return false;\n}\n/* Combines entries and newEntries, while respecting the order of loaders in each.\n\nIterates through new entries. If the new entry also exists in existing entries,\nwe'll put in all of the loaders from existing entries that come before it (in case\nthose are pre-requisites). Any remaining existing entries are added at the end.\n\nSince webpack processes right-to-left, we're working backwards through the arrays\n*/\n\n\nfunction combineEntries(newEntries, existingEntries) {\n  var resultSet = []; // We're iterating through newEntries, this keeps track of where we are in the existingEntries\n\n  var existingEntriesIteratorIndex = existingEntries.length - 1;\n\n  for (var i = newEntries.length - 1; i >= 0; i -= 1) {\n    var currentEntry = newEntries[i];\n    var indexInExistingEntries = findLastIndexUsingComparinator(existingEntries, currentEntry, areEqualEntries, existingEntriesIteratorIndex);\n    var hasEquivalentEntryInExistingEntries = indexInExistingEntries !== -1;\n\n    if (hasEquivalentEntryInExistingEntries) {\n      // If the same entry exists in existing entries, we should add all of the entries that\n      // come before to maintain order\n      for (var j = existingEntriesIteratorIndex; j > indexInExistingEntries; j -= 1) {\n        var existingEntry = existingEntries[j]; // If this entry also exists in new entries, we'll add as part of iterating through\n        // new entries so that if there's a conflict between existing entries and new entries,\n        // new entries order wins\n\n        var hasMatchingEntryInNewEntries = findLastIndexUsingComparinator(newEntries, existingEntry, areEqualEntries, i) !== -1;\n\n        if (!hasMatchingEntryInNewEntries) {\n          resultSet.unshift(existingEntry);\n        }\n\n        existingEntriesIteratorIndex -= 1;\n      }\n\n      uniteEntries(currentEntry, existingEntries[existingEntriesIteratorIndex]); // uniteEntries mutates the second parameter to be a merged version, so that's what's pushed\n\n      resultSet.unshift(existingEntries[existingEntriesIteratorIndex]);\n      existingEntriesIteratorIndex -= 1;\n    } else {\n      var alreadyHasMatchingEntryInResultSet = findLastIndexUsingComparinator(resultSet, currentEntry, areEqualEntries) !== -1;\n\n      if (!alreadyHasMatchingEntryInResultSet) {\n        resultSet.unshift(currentEntry);\n      }\n    }\n  } // Add remaining existing entries\n\n\n  for (existingEntriesIteratorIndex; existingEntriesIteratorIndex >= 0; existingEntriesIteratorIndex -= 1) {\n    var _existingEntry = existingEntries[existingEntriesIteratorIndex];\n\n    var _alreadyHasMatchingEntryInResultSet = findLastIndexUsingComparinator(resultSet, _existingEntry, areEqualEntries) !== -1;\n\n    if (!_alreadyHasMatchingEntryInResultSet) {\n      resultSet.unshift(_existingEntry);\n    }\n  }\n\n  return resultSet;\n}\n\nfunction findLastIndexUsingComparinator(entries, entryToFind, comparinator, startingIndex) {\n  startingIndex = startingIndex || entries.length - 1;\n\n  for (var i = startingIndex; i >= 0; i -= 1) {\n    if (areEqualEntries(entryToFind, entries[i])) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nexports.uniteRules = uniteRules;\nexports.uniteEntries = uniteEntries;","map":{"version":3,"sources":["C:/Users/Dell/Desktop/projects/hac-portfolio/node_modules/webpack-merge/lib/join-arrays-smart.js"],"names":["Object","defineProperty","exports","value","uniteEntries","uniteRules","undefined","_unionWith2","require","_unionWith3","_interopRequireDefault","_differenceWith2","_differenceWith3","_mergeWith2","_mergeWith3","_isEqual2","_isEqual3","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","_i","Symbol","iterator","_s","next","done","push","length","err","Array","isArray","TypeError","obj","__esModule","default","_toConsumableArray","arr2","from","rules","key","newRule","rule","String","test","enforce","include","isSameValue","exclude","loader","split","oneOf","bind","optionsKey","options","query","use","loaders","expandEntry","unwrapEntry","entry","entries","_optionsKey","concat","map","newEntries","loadersKey","resolvedKey","combineEntries","a","b","_map","sort","_map2","propA","propB","areEqualEntries","newEntry","loaderNameRe","_entry$loader$match","match","_entry$loader$match2","loaderName","_newEntry$loader$matc","_newEntry$loader$matc2","newLoaderName","existingEntries","resultSet","existingEntriesIteratorIndex","currentEntry","indexInExistingEntries","findLastIndexUsingComparinator","hasEquivalentEntryInExistingEntries","j","existingEntry","hasMatchingEntryInNewEntries","unshift","alreadyHasMatchingEntryInResultSet","_existingEntry","_alreadyHasMatchingEntryInResultSet","entryToFind","comparinator","startingIndex"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.uniteEntries = exports.uniteRules = undefined;\n\nvar _unionWith2 = require('lodash/unionWith');\n\nvar _unionWith3 = _interopRequireDefault(_unionWith2);\n\nvar _differenceWith2 = require('lodash/differenceWith');\n\nvar _differenceWith3 = _interopRequireDefault(_differenceWith2);\n\nvar _mergeWith2 = require('lodash/mergeWith');\n\nvar _mergeWith3 = _interopRequireDefault(_mergeWith2);\n\nvar _isEqual2 = require('lodash/isEqual');\n\nvar _isEqual3 = _interopRequireDefault(_isEqual2);\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar isArray = Array.isArray;\n\nfunction uniteRules(rules, key, newRule, rule) {\n  if (String(rule.test) !== String(newRule.test) || (newRule.enforce || rule.enforce) && rule.enforce !== newRule.enforce || newRule.include && !isSameValue(rule.include, newRule.include) || newRule.exclude && !isSameValue(rule.exclude, newRule.exclude)) {\n    return false;\n  } else if (!rule.test && !rule.include && !rule.exclude && (rule.loader && rule.loader.split('?')[0]) !== (newRule.loader && newRule.loader.split('?')[0])) {\n    // Don't merge the rule if there isn't any identifying fields and the loaders don't match\n    return false;\n  } else if ((rule.include || rule.exclude) && !newRule.include && !newRule.exclude) {\n    // Don't merge child without include/exclude to parent that has either\n    return false;\n  }\n\n  // apply the same logic for oneOf\n  if (rule.oneOf && newRule.oneOf) {\n    rule.oneOf = (0, _unionWith3.default)(rule.oneOf, newRule.oneOf, uniteRules.bind(null, {}, 'oneOf'));\n\n    return true;\n  }\n\n  // newRule.loader should always override use, loaders and oneOf\n  if (newRule.loader) {\n    var optionsKey = newRule.options ? 'options' : newRule.query && 'query';\n\n    delete rule.use;\n    delete rule.loaders;\n    delete rule.oneOf;\n\n    rule.loader = newRule.loader;\n\n    if (optionsKey) {\n      rule[optionsKey] = newRule[optionsKey];\n    }\n  } else if (newRule.oneOf) {\n    delete rule.use;\n    delete rule.loaders;\n    delete rule.loader;\n\n    rule.oneOf = newRule.oneOf;\n  } else if ((rule.use || rule.loaders || rule.loader) && (newRule.use || newRule.loaders)) {\n    var expandEntry = function expandEntry(loader) {\n      return typeof loader === 'string' ? { loader: loader } : loader;\n    };\n    // this is only here to avoid breaking existing tests\n    var unwrapEntry = function unwrapEntry(entry) {\n      return !entry.options && !entry.query ? entry.loader : entry;\n    };\n\n    var entries = void 0;\n    if (rule.loader) {\n      var _optionsKey = rule.options ? 'options' : rule.query && 'query';\n      entries = [{ loader: rule.loader }];\n\n      if (_optionsKey) {\n        entries[0][_optionsKey] = rule[_optionsKey];\n      }\n\n      delete rule.loader;\n\n      if (_optionsKey) {\n        delete rule[_optionsKey];\n      }\n    } else {\n      entries = [].concat(rule.use || rule.loaders).map(expandEntry);\n    }\n    var newEntries = [].concat(newRule.use || newRule.loaders).map(expandEntry);\n\n    var loadersKey = rule.use || newRule.use ? 'use' : 'loaders';\n    var resolvedKey = key + '.' + loadersKey;\n\n    switch (rules[resolvedKey]) {\n      case 'prepend':\n        rule[loadersKey] = [].concat(_toConsumableArray((0, _differenceWith3.default)(newEntries, entries, uniteEntries)), _toConsumableArray(entries)).map(unwrapEntry);\n        break;\n      case 'replace':\n        rule[loadersKey] = newRule.use || newRule.loaders;\n        break;\n      default:\n        rule[loadersKey] = combineEntries(newEntries, entries).map(unwrapEntry);\n    }\n  }\n\n  if (newRule.include) {\n    rule.include = newRule.include;\n  }\n\n  if (newRule.exclude) {\n    rule.exclude = newRule.exclude;\n  }\n\n  return true;\n}\n\n/**\n * Check equality of two values using lodash's isEqual\n * Arrays need to be sorted for equality checking\n * but clone them first so as not to disrupt the sort order in tests\n */\nfunction isSameValue(a, b) {\n  var _map = [a, b].map(function (value) {\n    return isArray(value) ? [].concat(_toConsumableArray(value)).sort() : value;\n  }),\n      _map2 = _slicedToArray(_map, 2),\n      propA = _map2[0],\n      propB = _map2[1];\n\n  return (0, _isEqual3.default)(propA, propB);\n}\n\nfunction areEqualEntries(newEntry, entry) {\n  var loaderNameRe = /^([^?]+)/ig;\n\n  var _entry$loader$match = entry.loader.match(loaderNameRe),\n      _entry$loader$match2 = _slicedToArray(_entry$loader$match, 1),\n      loaderName = _entry$loader$match2[0];\n\n  var _newEntry$loader$matc = newEntry.loader.match(loaderNameRe),\n      _newEntry$loader$matc2 = _slicedToArray(_newEntry$loader$matc, 1),\n      newLoaderName = _newEntry$loader$matc2[0];\n\n  return loaderName === newLoaderName;\n}\n\nfunction uniteEntries(newEntry, entry) {\n  if (areEqualEntries(newEntry, entry)) {\n    // Replace query values with newer ones\n    (0, _mergeWith3.default)(entry, newEntry);\n    return true;\n  }\n  return false;\n}\n\n/* Combines entries and newEntries, while respecting the order of loaders in each.\n\nIterates through new entries. If the new entry also exists in existing entries,\nwe'll put in all of the loaders from existing entries that come before it (in case\nthose are pre-requisites). Any remaining existing entries are added at the end.\n\nSince webpack processes right-to-left, we're working backwards through the arrays\n*/\nfunction combineEntries(newEntries, existingEntries) {\n  var resultSet = [];\n\n  // We're iterating through newEntries, this keeps track of where we are in the existingEntries\n  var existingEntriesIteratorIndex = existingEntries.length - 1;\n\n  for (var i = newEntries.length - 1; i >= 0; i -= 1) {\n    var currentEntry = newEntries[i];\n    var indexInExistingEntries = findLastIndexUsingComparinator(existingEntries, currentEntry, areEqualEntries, existingEntriesIteratorIndex);\n    var hasEquivalentEntryInExistingEntries = indexInExistingEntries !== -1;\n\n    if (hasEquivalentEntryInExistingEntries) {\n      // If the same entry exists in existing entries, we should add all of the entries that\n      // come before to maintain order\n      for (var j = existingEntriesIteratorIndex; j > indexInExistingEntries; j -= 1) {\n        var existingEntry = existingEntries[j];\n\n        // If this entry also exists in new entries, we'll add as part of iterating through\n        // new entries so that if there's a conflict between existing entries and new entries,\n        // new entries order wins\n        var hasMatchingEntryInNewEntries = findLastIndexUsingComparinator(newEntries, existingEntry, areEqualEntries, i) !== -1;\n\n        if (!hasMatchingEntryInNewEntries) {\n          resultSet.unshift(existingEntry);\n        }\n        existingEntriesIteratorIndex -= 1;\n      }\n\n      uniteEntries(currentEntry, existingEntries[existingEntriesIteratorIndex]);\n      // uniteEntries mutates the second parameter to be a merged version, so that's what's pushed\n      resultSet.unshift(existingEntries[existingEntriesIteratorIndex]);\n\n      existingEntriesIteratorIndex -= 1;\n    } else {\n      var alreadyHasMatchingEntryInResultSet = findLastIndexUsingComparinator(resultSet, currentEntry, areEqualEntries) !== -1;\n\n      if (!alreadyHasMatchingEntryInResultSet) {\n        resultSet.unshift(currentEntry);\n      }\n    }\n  }\n\n  // Add remaining existing entries\n  for (existingEntriesIteratorIndex; existingEntriesIteratorIndex >= 0; existingEntriesIteratorIndex -= 1) {\n\n    var _existingEntry = existingEntries[existingEntriesIteratorIndex];\n    var _alreadyHasMatchingEntryInResultSet = findLastIndexUsingComparinator(resultSet, _existingEntry, areEqualEntries) !== -1;\n\n    if (!_alreadyHasMatchingEntryInResultSet) {\n      resultSet.unshift(_existingEntry);\n    }\n  }\n\n  return resultSet;\n}\n\nfunction findLastIndexUsingComparinator(entries, entryToFind, comparinator, startingIndex) {\n  startingIndex = startingIndex || entries.length - 1;\n  for (var i = startingIndex; i >= 0; i -= 1) {\n    if (areEqualEntries(entryToFind, entries[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nexports.uniteRules = uniteRules;\nexports.uniteEntries = uniteEntries;"]},"metadata":{},"sourceType":"script"}